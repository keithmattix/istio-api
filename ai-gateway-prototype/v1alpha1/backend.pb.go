// Copyright 2025 Istio Authors
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: ai-gateway-prototype/v1alpha1/backend.proto

// $schema: k8s.networking.gateway.v1alpha1.Backend
// $title: Backend
// $description: Prototype for WG AI Gateway's Backend resource.

package v1alpha1

import (
	_struct "github.com/golang/protobuf/ptypes/struct"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Backend_Destination_Type int32

const (
	// Default value.
	Backend_Destination_TYPE_UNSPECIFIED Backend_Destination_Type = 0
	// FQDN represents a fully qualified domain name.
	Backend_Destination_FQDN Backend_Destination_Type = 1
	// IP represents an IP address.
	Backend_Destination_IP Backend_Destination_Type = 2
	// KubernetesService represents a Kubernetes Service.
	Backend_Destination_KubernetesService Backend_Destination_Type = 3
)

// Enum value maps for Backend_Destination_Type.
var (
	Backend_Destination_Type_name = map[int32]string{
		0: "TYPE_UNSPECIFIED",
		1: "FQDN",
		2: "IP",
		3: "KubernetesService",
	}
	Backend_Destination_Type_value = map[string]int32{
		"TYPE_UNSPECIFIED":  0,
		"FQDN":              1,
		"IP":                2,
		"KubernetesService": 3,
	}
)

func (x Backend_Destination_Type) Enum() *Backend_Destination_Type {
	p := new(Backend_Destination_Type)
	*p = x
	return p
}

func (x Backend_Destination_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Backend_Destination_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_ai_gateway_prototype_v1alpha1_backend_proto_enumTypes[0].Descriptor()
}

func (Backend_Destination_Type) Type() protoreflect.EnumType {
	return &file_ai_gateway_prototype_v1alpha1_backend_proto_enumTypes[0]
}

func (x Backend_Destination_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Backend_Destination_Type.Descriptor instead.
func (Backend_Destination_Type) EnumDescriptor() ([]byte, []int) {
	return file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescGZIP(), []int{0, 0, 0}
}

// TODO: Add fields as needed.
type Backend_Destination_ServicePort_TLS_FrontendTLS_Mode int32

const (
	Backend_Destination_ServicePort_TLS_FrontendTLS_UNSPECIFIED Backend_Destination_ServicePort_TLS_FrontendTLS_Mode = 0
	Backend_Destination_ServicePort_TLS_FrontendTLS_TERMINATE   Backend_Destination_ServicePort_TLS_FrontendTLS_Mode = 1
	Backend_Destination_ServicePort_TLS_FrontendTLS_PASSTHROUGH Backend_Destination_ServicePort_TLS_FrontendTLS_Mode = 2
)

// Enum value maps for Backend_Destination_ServicePort_TLS_FrontendTLS_Mode.
var (
	Backend_Destination_ServicePort_TLS_FrontendTLS_Mode_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "TERMINATE",
		2: "PASSTHROUGH",
	}
	Backend_Destination_ServicePort_TLS_FrontendTLS_Mode_value = map[string]int32{
		"UNSPECIFIED": 0,
		"TERMINATE":   1,
		"PASSTHROUGH": 2,
	}
)

func (x Backend_Destination_ServicePort_TLS_FrontendTLS_Mode) Enum() *Backend_Destination_ServicePort_TLS_FrontendTLS_Mode {
	p := new(Backend_Destination_ServicePort_TLS_FrontendTLS_Mode)
	*p = x
	return p
}

func (x Backend_Destination_ServicePort_TLS_FrontendTLS_Mode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Backend_Destination_ServicePort_TLS_FrontendTLS_Mode) Descriptor() protoreflect.EnumDescriptor {
	return file_ai_gateway_prototype_v1alpha1_backend_proto_enumTypes[1].Descriptor()
}

func (Backend_Destination_ServicePort_TLS_FrontendTLS_Mode) Type() protoreflect.EnumType {
	return &file_ai_gateway_prototype_v1alpha1_backend_proto_enumTypes[1]
}

func (x Backend_Destination_ServicePort_TLS_FrontendTLS_Mode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Backend_Destination_ServicePort_TLS_FrontendTLS_Mode.Descriptor instead.
func (Backend_Destination_ServicePort_TLS_FrontendTLS_Mode) EnumDescriptor() ([]byte, []int) {
	return file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescGZIP(), []int{0, 0, 1, 0, 2, 0}
}

type Backend_Destination_ServicePort_TLS_BackendTLS_Mode int32

const (
	// Default value.
	Backend_Destination_ServicePort_TLS_BackendTLS_UNSPECIFIED Backend_Destination_ServicePort_TLS_BackendTLS_Mode = 0
	// Enable TLS to the backend with simple verification of the server
	// certificate. The trust chain will default to system CA
	// certificates unless specified in other fields.
	Backend_Destination_ServicePort_TLS_BackendTLS_SIMPLE Backend_Destination_ServicePort_TLS_BackendTLS_Mode = 1
	// Enable mutual TLS. The trust chain will default to system CA
	// certificates unless specified in other fields.
	Backend_Destination_ServicePort_TLS_BackendTLS_MUTUAL Backend_Destination_ServicePort_TLS_BackendTLS_Mode = 2
	// Configures the implementation to use its built in TLS method if
	// it has one (e.g. a service mesh's mTLS). Be aware that without
	// properly configured TLS at the platform level, this field may
	// lead to insecure connections.
	// TODO(keithmattix): is this worth even having? Is Gateway API's
	// `options` field a better model?
	Backend_Destination_ServicePort_TLS_BackendTLS_PLATFORM_PROVIDED Backend_Destination_ServicePort_TLS_BackendTLS_Mode = 3
	// Disable TLS.
	Backend_Destination_ServicePort_TLS_BackendTLS_INSECURE_DISABLE Backend_Destination_ServicePort_TLS_BackendTLS_Mode = 4
)

// Enum value maps for Backend_Destination_ServicePort_TLS_BackendTLS_Mode.
var (
	Backend_Destination_ServicePort_TLS_BackendTLS_Mode_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "SIMPLE",
		2: "MUTUAL",
		3: "PLATFORM_PROVIDED",
		4: "INSECURE_DISABLE",
	}
	Backend_Destination_ServicePort_TLS_BackendTLS_Mode_value = map[string]int32{
		"UNSPECIFIED":       0,
		"SIMPLE":            1,
		"MUTUAL":            2,
		"PLATFORM_PROVIDED": 3,
		"INSECURE_DISABLE":  4,
	}
)

func (x Backend_Destination_ServicePort_TLS_BackendTLS_Mode) Enum() *Backend_Destination_ServicePort_TLS_BackendTLS_Mode {
	p := new(Backend_Destination_ServicePort_TLS_BackendTLS_Mode)
	*p = x
	return p
}

func (x Backend_Destination_ServicePort_TLS_BackendTLS_Mode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Backend_Destination_ServicePort_TLS_BackendTLS_Mode) Descriptor() protoreflect.EnumDescriptor {
	return file_ai_gateway_prototype_v1alpha1_backend_proto_enumTypes[2].Descriptor()
}

func (Backend_Destination_ServicePort_TLS_BackendTLS_Mode) Type() protoreflect.EnumType {
	return &file_ai_gateway_prototype_v1alpha1_backend_proto_enumTypes[2]
}

func (x Backend_Destination_ServicePort_TLS_BackendTLS_Mode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Backend_Destination_ServicePort_TLS_BackendTLS_Mode.Descriptor instead.
func (Backend_Destination_ServicePort_TLS_BackendTLS_Mode) EnumDescriptor() ([]byte, []int) {
	return file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescGZIP(), []int{0, 0, 1, 0, 3, 0}
}

// Backends provide a first-class way to describe external destinations
// (for example, FQDNs) and the connection policy needed to reach them.
//
// <!-- crd generation tags
// +cue-gen:Backend:groupName:gateway.networking.k8s.istio.io
// +cue-gen:Backend:versions:v1alpha1
// +cue-gen:Backend:annotations:helm.sh/resource-policy=keep
// +cue-gen:Backend:labels:app=istio-pilot,chart=istio,heritage=Tiller,release=istio
// +cue-gen:Backend:subresource:status
// +cue-gen:Backend:scope:Namespaced
// +cue-gen:Backend:resource:categories=istio-io,gateway-networking-k8s-istio-io
// +cue-gen:Backend:printerColumn:name=Host,type=string,JSONPath=.spec.destination.fqdn.hostname,description="The
// name of a service from the service registry"
// +cue-gen:Backend:printerColumn:name=Age,type=date,JSONPath=.metadata.creationTimestamp,description="CreationTimestamp
// is a timestamp representing the server time when this object was created. It
// is not guaranteed to be set in happens-before order across separate
// operations. Clients may not set this value. It is represented in RFC3339 form
// and is in UTC. Populated by the system. Read-only. Null for lists. For more
// information, see [Kubernetes API
// Conventions](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata)"
// +cue-gen:Backend:preserveUnknownFields:false
// -->
//
// <!-- go code generation tags
// +kubetype-gen
// +kubetype-gen:groupVersion=gateway.networking.k8s.istio.io/v1alpha1
// +genclient
// +k8s:deepcopy-gen=true
// -->
type Backend struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Destination   *Backend_Destination   `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	Extensions    []*Backend_Extension   `protobuf:"bytes,2,rep,name=extensions,proto3" json:"extensions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Backend) Reset() {
	*x = Backend{}
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backend) ProtoMessage() {}

func (x *Backend) ProtoReflect() protoreflect.Message {
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backend.ProtoReflect.Descriptor instead.
func (*Backend) Descriptor() ([]byte, []int) {
	return file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescGZIP(), []int{0}
}

func (x *Backend) GetDestination() *Backend_Destination {
	if x != nil {
		return x.Destination
	}
	return nil
}

func (x *Backend) GetExtensions() []*Backend_Extension {
	if x != nil {
		return x.Extensions
	}
	return nil
}

type Backend_Destination struct {
	state protoimpl.MessageState             `protogen:"open.v1"`
	Type  Backend_Destination_Type           `protobuf:"varint,1,opt,name=type,proto3,enum=gateway.networking.k8s.istio.v1alpha1.Backend_Destination_Type" json:"type,omitempty"`
	Ports []*Backend_Destination_ServicePort `protobuf:"bytes,2,rep,name=ports,proto3" json:"ports,omitempty"`
	// Types that are valid to be assigned to Dest:
	//
	//	*Backend_Destination_Fqdn
	Dest          isBackend_Destination_Dest `protobuf_oneof:"dest"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Backend_Destination) Reset() {
	*x = Backend_Destination{}
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backend_Destination) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backend_Destination) ProtoMessage() {}

func (x *Backend_Destination) ProtoReflect() protoreflect.Message {
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backend_Destination.ProtoReflect.Descriptor instead.
func (*Backend_Destination) Descriptor() ([]byte, []int) {
	return file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescGZIP(), []int{0, 0}
}

func (x *Backend_Destination) GetType() Backend_Destination_Type {
	if x != nil {
		return x.Type
	}
	return Backend_Destination_TYPE_UNSPECIFIED
}

func (x *Backend_Destination) GetPorts() []*Backend_Destination_ServicePort {
	if x != nil {
		return x.Ports
	}
	return nil
}

func (x *Backend_Destination) GetDest() isBackend_Destination_Dest {
	if x != nil {
		return x.Dest
	}
	return nil
}

func (x *Backend_Destination) GetFqdn() *Backend_Destination_FullyQualifiedDomainName {
	if x != nil {
		if x, ok := x.Dest.(*Backend_Destination_Fqdn); ok {
			return x.Fqdn
		}
	}
	return nil
}

type isBackend_Destination_Dest interface {
	isBackend_Destination_Dest()
}

type Backend_Destination_Fqdn struct {
	// FQDN represents a fully qualified domain name.
	Fqdn *Backend_Destination_FullyQualifiedDomainName `protobuf:"bytes,3,opt,name=fqdn,proto3,oneof"`
}

func (*Backend_Destination_Fqdn) isBackend_Destination_Dest() {}

type Backend_Extension struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type          string                 `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Config        *_struct.Struct        `protobuf:"bytes,3,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Backend_Extension) Reset() {
	*x = Backend_Extension{}
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backend_Extension) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backend_Extension) ProtoMessage() {}

func (x *Backend_Extension) ProtoReflect() protoreflect.Message {
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backend_Extension.ProtoReflect.Descriptor instead.
func (*Backend_Extension) Descriptor() ([]byte, []int) {
	return file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescGZIP(), []int{0, 1}
}

func (x *Backend_Extension) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Backend_Extension) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *Backend_Extension) GetConfig() *_struct.Struct {
	if x != nil {
		return x.Config
	}
	return nil
}

type Backend_Destination_FullyQualifiedDomainName struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Hostname represents the fully qualified domain name of the backend
	// service.
	//
	// Examples: "api.example.com", "backend.default.svc.cluster.local"
	Hostname      string `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Backend_Destination_FullyQualifiedDomainName) Reset() {
	*x = Backend_Destination_FullyQualifiedDomainName{}
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backend_Destination_FullyQualifiedDomainName) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backend_Destination_FullyQualifiedDomainName) ProtoMessage() {}

func (x *Backend_Destination_FullyQualifiedDomainName) ProtoReflect() protoreflect.Message {
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backend_Destination_FullyQualifiedDomainName.ProtoReflect.Descriptor instead.
func (*Backend_Destination_FullyQualifiedDomainName) Descriptor() ([]byte, []int) {
	return file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescGZIP(), []int{0, 0, 0}
}

func (x *Backend_Destination_FullyQualifiedDomainName) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

// ServicePort describes the properties of a specific port of a service.
type Backend_Destination_ServicePort struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A valid non-negative integer port number.
	// +kubebuilder:validation:XValidation:message="port must be between 1-65535",rule="0 < self && self <= 65535"
	Number uint32 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	// The protocol exposed on the port.
	// MUST be one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TLS|MCP.
	// TLS implies the connection will be routed based on the SNI header to
	// the destination without terminating the TLS connection.
	// +kubebuilder:validation:MaxLength=256
	Protocol string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Label assigned to the port.
	// +kubebuilder:validation:MaxLength=256
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The port number on the endpoint where the traffic will be
	// received. If unset, default to `number`.
	// +kubebuilder:validation:XValidation:message="port must be between 1-65535",rule="0 < self && self <= 65535"
	TargetPort uint32 `protobuf:"varint,4,opt,name=target_port,json=targetPort,proto3" json:"target_port,omitempty"`
	// Optional TLS settings for connections to this port.
	Tls *Backend_Destination_ServicePort_TLS `protobuf:"bytes,5,opt,name=tls,proto3" json:"tls,omitempty"`
	// Optional protocol-specific (excluding TLS) options for connections to this port.
	ProtocolOptions *Backend_Destination_ServicePort_ProtocolOptions `protobuf:"bytes,6,opt,name=protocol_options,json=protocolOptions,proto3" json:"protocol_options,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Backend_Destination_ServicePort) Reset() {
	*x = Backend_Destination_ServicePort{}
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backend_Destination_ServicePort) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backend_Destination_ServicePort) ProtoMessage() {}

func (x *Backend_Destination_ServicePort) ProtoReflect() protoreflect.Message {
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backend_Destination_ServicePort.ProtoReflect.Descriptor instead.
func (*Backend_Destination_ServicePort) Descriptor() ([]byte, []int) {
	return file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescGZIP(), []int{0, 0, 1}
}

func (x *Backend_Destination_ServicePort) GetNumber() uint32 {
	if x != nil {
		return x.Number
	}
	return 0
}

func (x *Backend_Destination_ServicePort) GetProtocol() string {
	if x != nil {
		return x.Protocol
	}
	return ""
}

func (x *Backend_Destination_ServicePort) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Backend_Destination_ServicePort) GetTargetPort() uint32 {
	if x != nil {
		return x.TargetPort
	}
	return 0
}

func (x *Backend_Destination_ServicePort) GetTls() *Backend_Destination_ServicePort_TLS {
	if x != nil {
		return x.Tls
	}
	return nil
}

func (x *Backend_Destination_ServicePort) GetProtocolOptions() *Backend_Destination_ServicePort_ProtocolOptions {
	if x != nil {
		return x.ProtocolOptions
	}
	return nil
}

type Backend_Destination_ServicePort_TLS struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// optional TLS settings for connections from the in-cluster client
	// to the bump in the wire (e.g. an egress gateway) sitting in front
	// of this backend.
	Frontend *Backend_Destination_ServicePort_TLS_FrontendTLS `protobuf:"bytes,1,opt,name=frontend,proto3" json:"frontend,omitempty"`
	// Configuration governing the communication to the upstream backend.
	// If this Backend is behind an egress gateway, this field governs the
	// TLS settings from the egress gateway to the backend. Deployments not
	// using a gateway will use this field to configure TLS settings
	// directly to the backend. Optional if frontend.mode is set to
	// PASSTHROUGH.
	Backend       *Backend_Destination_ServicePort_TLS_BackendTLS `protobuf:"bytes,2,opt,name=backend,proto3" json:"backend,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Backend_Destination_ServicePort_TLS) Reset() {
	*x = Backend_Destination_ServicePort_TLS{}
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backend_Destination_ServicePort_TLS) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backend_Destination_ServicePort_TLS) ProtoMessage() {}

func (x *Backend_Destination_ServicePort_TLS) ProtoReflect() protoreflect.Message {
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backend_Destination_ServicePort_TLS.ProtoReflect.Descriptor instead.
func (*Backend_Destination_ServicePort_TLS) Descriptor() ([]byte, []int) {
	return file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescGZIP(), []int{0, 0, 1, 0}
}

func (x *Backend_Destination_ServicePort_TLS) GetFrontend() *Backend_Destination_ServicePort_TLS_FrontendTLS {
	if x != nil {
		return x.Frontend
	}
	return nil
}

func (x *Backend_Destination_ServicePort_TLS) GetBackend() *Backend_Destination_ServicePort_TLS_BackendTLS {
	if x != nil {
		return x.Backend
	}
	return nil
}

type Backend_Destination_ServicePort_ProtocolOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Options:
	//
	//	*Backend_Destination_ServicePort_ProtocolOptions_Mcp
	Options       isBackend_Destination_ServicePort_ProtocolOptions_Options `protobuf_oneof:"options"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Backend_Destination_ServicePort_ProtocolOptions) Reset() {
	*x = Backend_Destination_ServicePort_ProtocolOptions{}
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backend_Destination_ServicePort_ProtocolOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backend_Destination_ServicePort_ProtocolOptions) ProtoMessage() {}

func (x *Backend_Destination_ServicePort_ProtocolOptions) ProtoReflect() protoreflect.Message {
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backend_Destination_ServicePort_ProtocolOptions.ProtoReflect.Descriptor instead.
func (*Backend_Destination_ServicePort_ProtocolOptions) Descriptor() ([]byte, []int) {
	return file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescGZIP(), []int{0, 0, 1, 1}
}

func (x *Backend_Destination_ServicePort_ProtocolOptions) GetOptions() isBackend_Destination_ServicePort_ProtocolOptions_Options {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *Backend_Destination_ServicePort_ProtocolOptions) GetMcp() *Backend_Destination_ServicePort_ProtocolOptions_MCPOptions {
	if x != nil {
		if x, ok := x.Options.(*Backend_Destination_ServicePort_ProtocolOptions_Mcp); ok {
			return x.Mcp
		}
	}
	return nil
}

type isBackend_Destination_ServicePort_ProtocolOptions_Options interface {
	isBackend_Destination_ServicePort_ProtocolOptions_Options()
}

type Backend_Destination_ServicePort_ProtocolOptions_Mcp struct {
	Mcp *Backend_Destination_ServicePort_ProtocolOptions_MCPOptions `protobuf:"bytes,1,opt,name=mcp,proto3,oneof"`
}

func (*Backend_Destination_ServicePort_ProtocolOptions_Mcp) isBackend_Destination_ServicePort_ProtocolOptions_Options() {
}

type Backend_Destination_ServicePort_TLS_CertificateReference struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Cert:
	//
	//	*Backend_Destination_ServicePort_TLS_CertificateReference_SecretName
	//	*Backend_Destination_ServicePort_TLS_CertificateReference_FilePath
	Cert          isBackend_Destination_ServicePort_TLS_CertificateReference_Cert `protobuf_oneof:"cert"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Backend_Destination_ServicePort_TLS_CertificateReference) Reset() {
	*x = Backend_Destination_ServicePort_TLS_CertificateReference{}
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backend_Destination_ServicePort_TLS_CertificateReference) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backend_Destination_ServicePort_TLS_CertificateReference) ProtoMessage() {}

func (x *Backend_Destination_ServicePort_TLS_CertificateReference) ProtoReflect() protoreflect.Message {
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backend_Destination_ServicePort_TLS_CertificateReference.ProtoReflect.Descriptor instead.
func (*Backend_Destination_ServicePort_TLS_CertificateReference) Descriptor() ([]byte, []int) {
	return file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescGZIP(), []int{0, 0, 1, 0, 0}
}

func (x *Backend_Destination_ServicePort_TLS_CertificateReference) GetCert() isBackend_Destination_ServicePort_TLS_CertificateReference_Cert {
	if x != nil {
		return x.Cert
	}
	return nil
}

func (x *Backend_Destination_ServicePort_TLS_CertificateReference) GetSecretName() string {
	if x != nil {
		if x, ok := x.Cert.(*Backend_Destination_ServicePort_TLS_CertificateReference_SecretName); ok {
			return x.SecretName
		}
	}
	return ""
}

func (x *Backend_Destination_ServicePort_TLS_CertificateReference) GetFilePath() string {
	if x != nil {
		if x, ok := x.Cert.(*Backend_Destination_ServicePort_TLS_CertificateReference_FilePath); ok {
			return x.FilePath
		}
	}
	return ""
}

type isBackend_Destination_ServicePort_TLS_CertificateReference_Cert interface {
	isBackend_Destination_ServicePort_TLS_CertificateReference_Cert()
}

type Backend_Destination_ServicePort_TLS_CertificateReference_SecretName struct {
	// Reference to a Kubernetes Secret containing the certificate in PEM
	// format.
	// TODO: Define keys in the Secret including private key, server cert,
	// CRLs, etc.
	SecretName string `protobuf:"bytes,1,opt,name=secret_name,json=secretName,proto3,oneof"`
}

type Backend_Destination_ServicePort_TLS_CertificateReference_FilePath struct {
	// Reference to a file containing the certificate in PEM format.
	FilePath string `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3,oneof"`
}

func (*Backend_Destination_ServicePort_TLS_CertificateReference_SecretName) isBackend_Destination_ServicePort_TLS_CertificateReference_Cert() {
}

func (*Backend_Destination_ServicePort_TLS_CertificateReference_FilePath) isBackend_Destination_ServicePort_TLS_CertificateReference_Cert() {
}

type Backend_Destination_ServicePort_TLS_CABundleReference struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to CaCert:
	//
	//	*Backend_Destination_ServicePort_TLS_CABundleReference_CredentialName
	//	*Backend_Destination_ServicePort_TLS_CABundleReference_FilePath
	CaCert        isBackend_Destination_ServicePort_TLS_CABundleReference_CaCert `protobuf_oneof:"ca_cert"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Backend_Destination_ServicePort_TLS_CABundleReference) Reset() {
	*x = Backend_Destination_ServicePort_TLS_CABundleReference{}
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backend_Destination_ServicePort_TLS_CABundleReference) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backend_Destination_ServicePort_TLS_CABundleReference) ProtoMessage() {}

func (x *Backend_Destination_ServicePort_TLS_CABundleReference) ProtoReflect() protoreflect.Message {
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backend_Destination_ServicePort_TLS_CABundleReference.ProtoReflect.Descriptor instead.
func (*Backend_Destination_ServicePort_TLS_CABundleReference) Descriptor() ([]byte, []int) {
	return file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescGZIP(), []int{0, 0, 1, 0, 1}
}

func (x *Backend_Destination_ServicePort_TLS_CABundleReference) GetCaCert() isBackend_Destination_ServicePort_TLS_CABundleReference_CaCert {
	if x != nil {
		return x.CaCert
	}
	return nil
}

func (x *Backend_Destination_ServicePort_TLS_CABundleReference) GetCredentialName() string {
	if x != nil {
		if x, ok := x.CaCert.(*Backend_Destination_ServicePort_TLS_CABundleReference_CredentialName); ok {
			return x.CredentialName
		}
	}
	return ""
}

func (x *Backend_Destination_ServicePort_TLS_CABundleReference) GetFilePath() string {
	if x != nil {
		if x, ok := x.CaCert.(*Backend_Destination_ServicePort_TLS_CABundleReference_FilePath); ok {
			return x.FilePath
		}
	}
	return ""
}

type isBackend_Destination_ServicePort_TLS_CABundleReference_CaCert interface {
	isBackend_Destination_ServicePort_TLS_CABundleReference_CaCert()
}

type Backend_Destination_ServicePort_TLS_CABundleReference_CredentialName struct {
	// Reference to a Kubernetes ConfigMap containing the CA certificate in
	// PEM format.
	// TODO: Define keys in the ConfigMap including CRLs
	CredentialName string `protobuf:"bytes,1,opt,name=credential_name,json=credentialName,proto3,oneof"`
}

type Backend_Destination_ServicePort_TLS_CABundleReference_FilePath struct {
	// Reference to a file containing the CA certificate in PEM format.
	FilePath string `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3,oneof"`
}

func (*Backend_Destination_ServicePort_TLS_CABundleReference_CredentialName) isBackend_Destination_ServicePort_TLS_CABundleReference_CaCert() {
}

func (*Backend_Destination_ServicePort_TLS_CABundleReference_FilePath) isBackend_Destination_ServicePort_TLS_CABundleReference_CaCert() {
}

type Backend_Destination_ServicePort_TLS_FrontendTLS struct {
	state protoimpl.MessageState                               `protogen:"open.v1"`
	Mode  Backend_Destination_ServicePort_TLS_FrontendTLS_Mode `protobuf:"varint,1,opt,name=mode,proto3,enum=gateway.networking.k8s.istio.v1alpha1.Backend_Destination_ServicePort_TLS_FrontendTLS_Mode" json:"mode,omitempty"`
	// Certificate presented to the in-cluster client when
	// frontend.mode is TERMINATE.
	FrontendCertificate *Backend_Destination_ServicePort_TLS_CertificateReference `protobuf:"bytes,2,opt,name=frontend_certificate,json=frontendCertificate,proto3" json:"frontend_certificate,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *Backend_Destination_ServicePort_TLS_FrontendTLS) Reset() {
	*x = Backend_Destination_ServicePort_TLS_FrontendTLS{}
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backend_Destination_ServicePort_TLS_FrontendTLS) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backend_Destination_ServicePort_TLS_FrontendTLS) ProtoMessage() {}

func (x *Backend_Destination_ServicePort_TLS_FrontendTLS) ProtoReflect() protoreflect.Message {
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backend_Destination_ServicePort_TLS_FrontendTLS.ProtoReflect.Descriptor instead.
func (*Backend_Destination_ServicePort_TLS_FrontendTLS) Descriptor() ([]byte, []int) {
	return file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescGZIP(), []int{0, 0, 1, 0, 2}
}

func (x *Backend_Destination_ServicePort_TLS_FrontendTLS) GetMode() Backend_Destination_ServicePort_TLS_FrontendTLS_Mode {
	if x != nil {
		return x.Mode
	}
	return Backend_Destination_ServicePort_TLS_FrontendTLS_UNSPECIFIED
}

func (x *Backend_Destination_ServicePort_TLS_FrontendTLS) GetFrontendCertificate() *Backend_Destination_ServicePort_TLS_CertificateReference {
	if x != nil {
		return x.FrontendCertificate
	}
	return nil
}

type Backend_Destination_ServicePort_TLS_BackendTLS struct {
	state           protoimpl.MessageState                              `protogen:"open.v1"`
	Mode            Backend_Destination_ServicePort_TLS_BackendTLS_Mode `protobuf:"varint,1,opt,name=mode,proto3,enum=gateway.networking.k8s.istio.v1alpha1.Backend_Destination_ServicePort_TLS_BackendTLS_Mode" json:"mode,omitempty"`
	SubjectAltNames []string                                            `protobuf:"bytes,2,rep,name=subject_alt_names,json=subjectAltNames,proto3" json:"subject_alt_names,omitempty"`
	// SNI to present when initializing TLS to the backend. If unset, SNI
	// will be set automatically based on host/authority header for SIMPLE
	// and MUTUAL TLS modes.
	Sni string `protobuf:"bytes,3,opt,name=sni,proto3" json:"sni,omitempty"`
	// Client certificates to present to the backend.
	// Only used in MUTUAL mode.
	ClientCertificates *Backend_Destination_ServicePort_TLS_CertificateReference `protobuf:"bytes,4,opt,name=client_certificates,json=clientCertificates,proto3" json:"client_certificates,omitempty"`
	// `insecureSkipVerify` specifies whether the proxy should skip
	// verifying the
	// CA signature and SAN for the server certificate corresponding to
	// the host. The default value of this field is false.
	InsecureSkipVerify *wrappers.BoolValue `protobuf:"bytes,5,opt,name=insecure_skip_verify,json=insecureSkipVerify,proto3" json:"insecure_skip_verify,omitempty"`
	// CA to validate the backend's server certificate.
	//
	// Types that are valid to be assigned to CaCertificates:
	//
	//	*Backend_Destination_ServicePort_TLS_BackendTLS_SystemCaCertificates
	//	*Backend_Destination_ServicePort_TLS_BackendTLS_CaBundleRef
	CaCertificates isBackend_Destination_ServicePort_TLS_BackendTLS_CaCertificates `protobuf_oneof:"ca_certificates"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Backend_Destination_ServicePort_TLS_BackendTLS) Reset() {
	*x = Backend_Destination_ServicePort_TLS_BackendTLS{}
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backend_Destination_ServicePort_TLS_BackendTLS) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backend_Destination_ServicePort_TLS_BackendTLS) ProtoMessage() {}

func (x *Backend_Destination_ServicePort_TLS_BackendTLS) ProtoReflect() protoreflect.Message {
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backend_Destination_ServicePort_TLS_BackendTLS.ProtoReflect.Descriptor instead.
func (*Backend_Destination_ServicePort_TLS_BackendTLS) Descriptor() ([]byte, []int) {
	return file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescGZIP(), []int{0, 0, 1, 0, 3}
}

func (x *Backend_Destination_ServicePort_TLS_BackendTLS) GetMode() Backend_Destination_ServicePort_TLS_BackendTLS_Mode {
	if x != nil {
		return x.Mode
	}
	return Backend_Destination_ServicePort_TLS_BackendTLS_UNSPECIFIED
}

func (x *Backend_Destination_ServicePort_TLS_BackendTLS) GetSubjectAltNames() []string {
	if x != nil {
		return x.SubjectAltNames
	}
	return nil
}

func (x *Backend_Destination_ServicePort_TLS_BackendTLS) GetSni() string {
	if x != nil {
		return x.Sni
	}
	return ""
}

func (x *Backend_Destination_ServicePort_TLS_BackendTLS) GetClientCertificates() *Backend_Destination_ServicePort_TLS_CertificateReference {
	if x != nil {
		return x.ClientCertificates
	}
	return nil
}

func (x *Backend_Destination_ServicePort_TLS_BackendTLS) GetInsecureSkipVerify() *wrappers.BoolValue {
	if x != nil {
		return x.InsecureSkipVerify
	}
	return nil
}

func (x *Backend_Destination_ServicePort_TLS_BackendTLS) GetCaCertificates() isBackend_Destination_ServicePort_TLS_BackendTLS_CaCertificates {
	if x != nil {
		return x.CaCertificates
	}
	return nil
}

func (x *Backend_Destination_ServicePort_TLS_BackendTLS) GetSystemCaCertificates() *wrappers.BoolValue {
	if x != nil {
		if x, ok := x.CaCertificates.(*Backend_Destination_ServicePort_TLS_BackendTLS_SystemCaCertificates); ok {
			return x.SystemCaCertificates
		}
	}
	return nil
}

func (x *Backend_Destination_ServicePort_TLS_BackendTLS) GetCaBundleRef() *Backend_Destination_ServicePort_TLS_CABundleReference {
	if x != nil {
		if x, ok := x.CaCertificates.(*Backend_Destination_ServicePort_TLS_BackendTLS_CaBundleRef); ok {
			return x.CaBundleRef
		}
	}
	return nil
}

type isBackend_Destination_ServicePort_TLS_BackendTLS_CaCertificates interface {
	isBackend_Destination_ServicePort_TLS_BackendTLS_CaCertificates()
}

type Backend_Destination_ServicePort_TLS_BackendTLS_SystemCaCertificates struct {
	// Use system CA certificates to validate the backend's server
	// certificate.
	SystemCaCertificates *wrappers.BoolValue `protobuf:"bytes,6,opt,name=system_ca_certificates,json=systemCaCertificates,proto3,oneof"`
}

type Backend_Destination_ServicePort_TLS_BackendTLS_CaBundleRef struct {
	CaBundleRef *Backend_Destination_ServicePort_TLS_CABundleReference `protobuf:"bytes,7,opt,name=ca_bundle_ref,json=caBundleRef,proto3,oneof"`
}

func (*Backend_Destination_ServicePort_TLS_BackendTLS_SystemCaCertificates) isBackend_Destination_ServicePort_TLS_BackendTLS_CaCertificates() {
}

func (*Backend_Destination_ServicePort_TLS_BackendTLS_CaBundleRef) isBackend_Destination_ServicePort_TLS_BackendTLS_CaCertificates() {
}

type Backend_Destination_ServicePort_ProtocolOptions_MCPOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The version of the MCP protocol to use.
	// MUST be one of V2|V3.
	// +kubebuilder:validation:MaxLength=256
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Path is the URL path of the MCP backend for MCP traffic.
	// A MCP backend may serve both MCP traffic and non-MCP traffic.
	// If not specified, the default is /mcp.
	// +optional
	// +kubebuilder:default:=/mcp
	Path          string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Backend_Destination_ServicePort_ProtocolOptions_MCPOptions) Reset() {
	*x = Backend_Destination_ServicePort_ProtocolOptions_MCPOptions{}
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backend_Destination_ServicePort_ProtocolOptions_MCPOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backend_Destination_ServicePort_ProtocolOptions_MCPOptions) ProtoMessage() {}

func (x *Backend_Destination_ServicePort_ProtocolOptions_MCPOptions) ProtoReflect() protoreflect.Message {
	mi := &file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backend_Destination_ServicePort_ProtocolOptions_MCPOptions.ProtoReflect.Descriptor instead.
func (*Backend_Destination_ServicePort_ProtocolOptions_MCPOptions) Descriptor() ([]byte, []int) {
	return file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescGZIP(), []int{0, 0, 1, 1, 0}
}

func (x *Backend_Destination_ServicePort_ProtocolOptions_MCPOptions) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *Backend_Destination_ServicePort_ProtocolOptions_MCPOptions) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

var File_ai_gateway_prototype_v1alpha1_backend_proto protoreflect.FileDescriptor

const file_ai_gateway_prototype_v1alpha1_backend_proto_rawDesc = "" +
	"\n" +
	"+ai-gateway-prototype/v1alpha1/backend.proto\x12%gateway.networking.k8s.istio.v1alpha1\x1a\x1fgoogle/api/field_behavior.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\x85\x16\n" +
	"\aBackend\x12\\\n" +
	"\vdestination\x18\x01 \x01(\v2:.gateway.networking.k8s.istio.v1alpha1.Backend.DestinationR\vdestination\x12X\n" +
	"\n" +
	"extensions\x18\x02 \x03(\v28.gateway.networking.k8s.istio.v1alpha1.Backend.ExtensionR\n" +
	"extensions\x1a\xdb\x13\n" +
	"\vDestination\x12S\n" +
	"\x04type\x18\x01 \x01(\x0e2?.gateway.networking.k8s.istio.v1alpha1.Backend.Destination.TypeR\x04type\x12\\\n" +
	"\x05ports\x18\x02 \x03(\v2F.gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePortR\x05ports\x12i\n" +
	"\x04fqdn\x18\x03 \x01(\v2S.gateway.networking.k8s.istio.v1alpha1.Backend.Destination.FullyQualifiedDomainNameH\x00R\x04fqdn\x1a6\n" +
	"\x18FullyQualifiedDomainName\x12\x1a\n" +
	"\bhostname\x18\x01 \x01(\tR\bhostname\x1a\xa6\x10\n" +
	"\vServicePort\x12\x1c\n" +
	"\x06number\x18\x01 \x01(\rB\x04\xe2A\x01\x02R\x06number\x12\x1a\n" +
	"\bprotocol\x18\x02 \x01(\tR\bprotocol\x12\x18\n" +
	"\x04name\x18\x03 \x01(\tB\x04\xe2A\x01\x02R\x04name\x12\x1f\n" +
	"\vtarget_port\x18\x04 \x01(\rR\n" +
	"targetPort\x12\\\n" +
	"\x03tls\x18\x05 \x01(\v2J.gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLSR\x03tls\x12\x81\x01\n" +
	"\x10protocol_options\x18\x06 \x01(\v2V.gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.ProtocolOptionsR\x0fprotocolOptions\x1a\xed\v\n" +
	"\x03TLS\x12r\n" +
	"\bfrontend\x18\x01 \x01(\v2V.gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.FrontendTLSR\bfrontend\x12o\n" +
	"\abackend\x18\x02 \x01(\v2U.gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.BackendTLSR\abackend\x1a`\n" +
	"\x14CertificateReference\x12!\n" +
	"\vsecret_name\x18\x01 \x01(\tH\x00R\n" +
	"secretName\x12\x1d\n" +
	"\tfile_path\x18\x02 \x01(\tH\x00R\bfilePathB\x06\n" +
	"\x04cert\x1ah\n" +
	"\x11CABundleReference\x12)\n" +
	"\x0fcredential_name\x18\x01 \x01(\tH\x00R\x0ecredentialName\x12\x1d\n" +
	"\tfile_path\x18\x02 \x01(\tH\x00R\bfilePathB\t\n" +
	"\aca_cert\x1a\xcc\x02\n" +
	"\vFrontendTLS\x12o\n" +
	"\x04mode\x18\x01 \x01(\x0e2[.gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.FrontendTLS.ModeR\x04mode\x12\x92\x01\n" +
	"\x14frontend_certificate\x18\x02 \x01(\v2_.gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.CertificateReferenceR\x13frontendCertificate\"7\n" +
	"\x04Mode\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\r\n" +
	"\tTERMINATE\x10\x01\x12\x0f\n" +
	"\vPASSTHROUGH\x10\x02\x1a\xe5\x05\n" +
	"\n" +
	"BackendTLS\x12n\n" +
	"\x04mode\x18\x01 \x01(\x0e2Z.gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.BackendTLS.ModeR\x04mode\x12*\n" +
	"\x11subject_alt_names\x18\x02 \x03(\tR\x0fsubjectAltNames\x12\x10\n" +
	"\x03sni\x18\x03 \x01(\tR\x03sni\x12\x90\x01\n" +
	"\x13client_certificates\x18\x04 \x01(\v2_.gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.CertificateReferenceR\x12clientCertificates\x12L\n" +
	"\x14insecure_skip_verify\x18\x05 \x01(\v2\x1a.google.protobuf.BoolValueR\x12insecureSkipVerify\x12R\n" +
	"\x16system_ca_certificates\x18\x06 \x01(\v2\x1a.google.protobuf.BoolValueH\x00R\x14systemCaCertificates\x12\x82\x01\n" +
	"\rca_bundle_ref\x18\a \x01(\v2\\.gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.CABundleReferenceH\x00R\vcaBundleRef\"\\\n" +
	"\x04Mode\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\n" +
	"\n" +
	"\x06SIMPLE\x10\x01\x12\n" +
	"\n" +
	"\x06MUTUAL\x10\x02\x12\x15\n" +
	"\x11PLATFORM_PROVIDED\x10\x03\x12\x14\n" +
	"\x10INSECURE_DISABLE\x10\x04B\x11\n" +
	"\x0fca_certificates\x1a\xcf\x01\n" +
	"\x0fProtocolOptions\x12u\n" +
	"\x03mcp\x18\x01 \x01(\v2a.gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.ProtocolOptions.MCPOptionsH\x00R\x03mcp\x1a:\n" +
	"\n" +
	"MCPOptions\x12\x18\n" +
	"\aversion\x18\x01 \x01(\tR\aversion\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04pathB\t\n" +
	"\aoptions\"E\n" +
	"\x04Type\x12\x14\n" +
	"\x10TYPE_UNSPECIFIED\x10\x00\x12\b\n" +
	"\x04FQDN\x10\x01\x12\x06\n" +
	"\x02IP\x10\x02\x12\x15\n" +
	"\x11KubernetesService\x10\x03B\x06\n" +
	"\x04dest\x1ad\n" +
	"\tExtension\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x12\n" +
	"\x04type\x18\x02 \x01(\tR\x04type\x12/\n" +
	"\x06config\x18\x03 \x01(\v2\x17.google.protobuf.StructR\x06configB,Z*istio.io/api/ai-gateway-prototype/v1alpha1b\x06proto3"

var (
	file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescOnce sync.Once
	file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescData []byte
)

func file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescGZIP() []byte {
	file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescOnce.Do(func() {
		file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_ai_gateway_prototype_v1alpha1_backend_proto_rawDesc), len(file_ai_gateway_prototype_v1alpha1_backend_proto_rawDesc)))
	})
	return file_ai_gateway_prototype_v1alpha1_backend_proto_rawDescData
}

var file_ai_gateway_prototype_v1alpha1_backend_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_ai_gateway_prototype_v1alpha1_backend_proto_goTypes = []any{
	(Backend_Destination_Type)(0),                             // 0: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.Type
	(Backend_Destination_ServicePort_TLS_FrontendTLS_Mode)(0), // 1: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.FrontendTLS.Mode
	(Backend_Destination_ServicePort_TLS_BackendTLS_Mode)(0),  // 2: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.BackendTLS.Mode
	(*Backend)(nil),                                                    // 3: gateway.networking.k8s.istio.v1alpha1.Backend
	(*Backend_Destination)(nil),                                        // 4: gateway.networking.k8s.istio.v1alpha1.Backend.Destination
	(*Backend_Extension)(nil),                                          // 5: gateway.networking.k8s.istio.v1alpha1.Backend.Extension
	(*Backend_Destination_FullyQualifiedDomainName)(nil),               // 6: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.FullyQualifiedDomainName
	(*Backend_Destination_ServicePort)(nil),                            // 7: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort
	(*Backend_Destination_ServicePort_TLS)(nil),                        // 8: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS
	(*Backend_Destination_ServicePort_ProtocolOptions)(nil),            // 9: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.ProtocolOptions
	(*Backend_Destination_ServicePort_TLS_CertificateReference)(nil),   // 10: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.CertificateReference
	(*Backend_Destination_ServicePort_TLS_CABundleReference)(nil),      // 11: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.CABundleReference
	(*Backend_Destination_ServicePort_TLS_FrontendTLS)(nil),            // 12: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.FrontendTLS
	(*Backend_Destination_ServicePort_TLS_BackendTLS)(nil),             // 13: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.BackendTLS
	(*Backend_Destination_ServicePort_ProtocolOptions_MCPOptions)(nil), // 14: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.ProtocolOptions.MCPOptions
	(*_struct.Struct)(nil),                                             // 15: google.protobuf.Struct
	(*wrappers.BoolValue)(nil),                                         // 16: google.protobuf.BoolValue
}
var file_ai_gateway_prototype_v1alpha1_backend_proto_depIdxs = []int32{
	4,  // 0: gateway.networking.k8s.istio.v1alpha1.Backend.destination:type_name -> gateway.networking.k8s.istio.v1alpha1.Backend.Destination
	5,  // 1: gateway.networking.k8s.istio.v1alpha1.Backend.extensions:type_name -> gateway.networking.k8s.istio.v1alpha1.Backend.Extension
	0,  // 2: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.type:type_name -> gateway.networking.k8s.istio.v1alpha1.Backend.Destination.Type
	7,  // 3: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ports:type_name -> gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort
	6,  // 4: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.fqdn:type_name -> gateway.networking.k8s.istio.v1alpha1.Backend.Destination.FullyQualifiedDomainName
	15, // 5: gateway.networking.k8s.istio.v1alpha1.Backend.Extension.config:type_name -> google.protobuf.Struct
	8,  // 6: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.tls:type_name -> gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS
	9,  // 7: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.protocol_options:type_name -> gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.ProtocolOptions
	12, // 8: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.frontend:type_name -> gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.FrontendTLS
	13, // 9: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.backend:type_name -> gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.BackendTLS
	14, // 10: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.ProtocolOptions.mcp:type_name -> gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.ProtocolOptions.MCPOptions
	1,  // 11: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.FrontendTLS.mode:type_name -> gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.FrontendTLS.Mode
	10, // 12: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.FrontendTLS.frontend_certificate:type_name -> gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.CertificateReference
	2,  // 13: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.BackendTLS.mode:type_name -> gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.BackendTLS.Mode
	10, // 14: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.BackendTLS.client_certificates:type_name -> gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.CertificateReference
	16, // 15: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.BackendTLS.insecure_skip_verify:type_name -> google.protobuf.BoolValue
	16, // 16: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.BackendTLS.system_ca_certificates:type_name -> google.protobuf.BoolValue
	11, // 17: gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.BackendTLS.ca_bundle_ref:type_name -> gateway.networking.k8s.istio.v1alpha1.Backend.Destination.ServicePort.TLS.CABundleReference
	18, // [18:18] is the sub-list for method output_type
	18, // [18:18] is the sub-list for method input_type
	18, // [18:18] is the sub-list for extension type_name
	18, // [18:18] is the sub-list for extension extendee
	0,  // [0:18] is the sub-list for field type_name
}

func init() { file_ai_gateway_prototype_v1alpha1_backend_proto_init() }
func file_ai_gateway_prototype_v1alpha1_backend_proto_init() {
	if File_ai_gateway_prototype_v1alpha1_backend_proto != nil {
		return
	}
	file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[1].OneofWrappers = []any{
		(*Backend_Destination_Fqdn)(nil),
	}
	file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[6].OneofWrappers = []any{
		(*Backend_Destination_ServicePort_ProtocolOptions_Mcp)(nil),
	}
	file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[7].OneofWrappers = []any{
		(*Backend_Destination_ServicePort_TLS_CertificateReference_SecretName)(nil),
		(*Backend_Destination_ServicePort_TLS_CertificateReference_FilePath)(nil),
	}
	file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[8].OneofWrappers = []any{
		(*Backend_Destination_ServicePort_TLS_CABundleReference_CredentialName)(nil),
		(*Backend_Destination_ServicePort_TLS_CABundleReference_FilePath)(nil),
	}
	file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes[10].OneofWrappers = []any{
		(*Backend_Destination_ServicePort_TLS_BackendTLS_SystemCaCertificates)(nil),
		(*Backend_Destination_ServicePort_TLS_BackendTLS_CaBundleRef)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_ai_gateway_prototype_v1alpha1_backend_proto_rawDesc), len(file_ai_gateway_prototype_v1alpha1_backend_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_ai_gateway_prototype_v1alpha1_backend_proto_goTypes,
		DependencyIndexes: file_ai_gateway_prototype_v1alpha1_backend_proto_depIdxs,
		EnumInfos:         file_ai_gateway_prototype_v1alpha1_backend_proto_enumTypes,
		MessageInfos:      file_ai_gateway_prototype_v1alpha1_backend_proto_msgTypes,
	}.Build()
	File_ai_gateway_prototype_v1alpha1_backend_proto = out.File
	file_ai_gateway_prototype_v1alpha1_backend_proto_goTypes = nil
	file_ai_gateway_prototype_v1alpha1_backend_proto_depIdxs = nil
}
